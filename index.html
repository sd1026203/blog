<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="记录我的学习历程">
<meta property="og:type" content="website">
<meta property="og:title" content="高山仰止,景行行止">
<meta property="og:url" content="sd1026203.github.io/index.html">
<meta property="og:site_name" content="高山仰止,景行行止">
<meta property="og:description" content="记录我的学习历程">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高山仰止,景行行止">
<meta name="twitter:description" content="记录我的学习历程">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="sd1026203.github.io/"/>





  <title>高山仰止,景行行止</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">高山仰止,景行行止</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天进步一点点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/09/15/58/comments_api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/15/58/comments_api/" itemprop="url">
                  评论接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T00:00:00+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/58/" itemprop="url" rel="index">
                    <span itemprop="name">58</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="入口请求"><a href="#入口请求" class="headerlink" title="入口请求"></a>入口请求</h2><p>url: /pinglun</p>
<p>跳转模板: pinglun</p>
<p>传入参数; cityid, channel</p>
<p>是否登录标志: isLogin, 1为已经登录, 0为未登录</p>
<h2 id="评论相关的返回值格式"><a href="#评论相关的返回值格式" class="headerlink" title="评论相关的返回值格式"></a>评论相关的返回值格式</h2><p>先说一下返回值的总体格式如下:</p>
<pre>
{ "data": null,

   "baseResponse": {
       "status": 0,
       "message": "成功"
   }
}
</pre>

<p>Data为具体返回值, 下面会罗列各个接口的返回data baseResponse为状态码<br>只有status为0的是正常返回, 1为系统异常, 3为参数异常, 4为业务异常, 5猎人审核异常</p>
<h2 id="评论前获取识别码"><a href="#评论前获取识别码" class="headerlink" title="评论前获取识别码"></a>评论前获取识别码</h2><p>点击输入框时, 应调用此接口, 接口返回字符串, 该字符串在新增评论时应作为参数回传, 有时效为1小时</p>
<p>url: /pinglun/getValidCodeBeforeAddNewComment</p>
<p>method: get</p>
<p>参数: 无</p>
<p>返回值: string</p>
<h2 id="新增评论"><a href="#新增评论" class="headerlink" title="新增评论"></a>新增评论</h2><p>用户新增评论 url : /pinglun/addNewComment method: Post 参数: addCommentModel</p>
<pre>
{
   "entityTitle": null, //标题不能为空
   "content": null, //评论内容不能为空, 最少1个字, 最多512
   "user": null,  //评论人, 后台获取
   "toUser": null, //被评论人, 前端传
   "partnerID": null,   //父评论ID
   "businessID": null,   //业务线ID, 头条为1
   "entityID": null, //文章ID不能为空
   "checkStatus": null,//传null
   "rejectReason": null,//传null
   "validCode": null  //识别码不能为空
}
</pre>

<p>返回值: Long, 评论ID</p>
<h2 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h2><p>对一条评论点赞 url: /pinglun/likeComment method: post 参数likeCommentModel</p>
<pre> 
{
  "user": null,  //用户
   "commentID": null,//评论ID不能为空
   "machineID": null//机器码不能为空
}
</pre>

<p>返回值: Integer, 目前该评论点赞数</p>
<h2 id="获取热门评论"><a href="#获取热门评论" class="headerlink" title="获取热门评论"></a>获取热门评论</h2><p>url: /pinglun/getHotComments method: get 参数: queryHotCommentsModel { “businessID”:null,//业务线ID “entityID”:null,//文章ID “machineID”:null//机器码 }</p>
<p>返回值: APPCommentModel列表: </p>
<pre> 
[
  {
       "entityTitle": null, //文章标题
       "content": null,//评论内容
       "user": null,//评论人
       "toUser": null,//被评论人
       "likeNum": null,//点赞数
       "commentaryNum": null,//被回复数
       "createdTime": null,//创建时间
       "partnerID": null,//父评论ID
       "whoLike": null,//点赞列表, user的list对象
       "checkStatus": null,//审核状态
       "commentID": null,//评论ID
       "businessID": null,//业务线ID
       "entityID": null,//文章ID
       "purchaseNote": null,//额外信息, 暂时没用
       "ifLiked": null //是否点过赞
   }
]
</pre>

<h2 id="获取一般评论"><a href="#获取一般评论" class="headerlink" title="获取一般评论"></a>获取一般评论</h2><p>url:/pinglun/getComments</p>
<p>method: get 参数: queryCommentsModel</p>
<pre>
{
   "businessID": null,
   "entityID": null,
   "pageNum": null, 页数最小为1
   "pageSize": null, 每页最少1条,最多20条
   "partnerID": null, 不能为空, 如果是查询一级评论请传0L
   "machineID": null手机ID不能为空
}
</pre>

<p>返回时: 同获取热门评论</p>
<h2 id="获取评论数"><a href="#获取评论数" class="headerlink" title="获取评论数"></a>获取评论数</h2><p>url:/pinglun/getEntityCommentCount</p>
<p>method: get<br>参数: businessID,  //业务线ID<br>         entityIDs       //文章ID列表</p>
<p>返回值: </p>
<pre>
[
        {
            "entityID": null,             //文章ID
            "commentCount": null //评论数
        }
]
</pre>

<h2 id="根据ID获取评论"><a href="#根据ID获取评论" class="headerlink" title="根据ID获取评论"></a>根据ID获取评论</h2><p>url: pinglun/getCommentsByID<br>method: get<br>参数: commentID  评论ID<br>返回值: 同获取热门评论</p>
<h2 id="User对象"><a href="#User对象" class="headerlink" title="User对象"></a>User对象</h2><p>{<br>    “id”: null,            //用户ID, 不能为空<br>    “uname”: null,   //用户名称, 不能为空<br>    “headImg”: null,//用户头像, 有就传, 没有不传<br>    “uip”: null          //用户IP<br>}</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/05/05/base/how_to_resolve_online_problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/05/base/how_to_resolve_online_problem/" itemprop="url">
                  一些线上问题的排查方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T00:00:00+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h1><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code>jstack -l pid &gt; jstack.log  线上机器需要切换至有权限用户
</code></pre><h3 id="线程信息中几种状态含义"><a href="#线程信息中几种状态含义" class="headerlink" title="线程信息中几种状态含义"></a>线程信息中几种状态含义</h3><ol>
<li>RUNNABLE 状态是线程正在正常运行中, 当然可能会有某种耗时计算/IO等待的操作/CPU时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁.</li>
<li>BLOCKED  这个状态下, 是在多个线程有同步操作的场景, 比如正在等待另一个线程的synchronized 块的执行释放, 或者可重入的 synchronized块里别人调用wait() 方法, 也就是这里是线程在等待进入临界区</li>
<li>WAITING（线 程池中从BlockingQueue.take()方法处常见）  这个状态下是指线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作, 这里要区分 BLOCKED 和 WATING 的区别, 一个是在临界点外面等待进入, 一个是在临界点里面wait等待别人notify, 线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束</li>
<li>TIMED_WAITING  这个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外一个线程sleep后, 也会进入TIMED_WAITING状态</li>
<li>TERMINATED 这个状态下表示 该线程的run方法已经执行完毕了, 基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收)</li>
</ol>
<h3 id="waiting状态及括号内容说明"><a href="#waiting状态及括号内容说明" class="headerlink" title="waiting状态及括号内容说明"></a>waiting状态及括号内容说明</h3><ol>
<li>sleeping: sleep状态, 调用了sleep()方法可进入此状态;</li>
<li>parking: 线程挂起, 可能是在等待其他线程唤醒;</li>
<li>on object monitor ： object.wait()方法可使线程进入这个状态</li>
</ol>
<h3 id="线程基本状态信息"><a href="#线程基本状态信息" class="headerlink" title="线程基本状态信息"></a>线程基本状态信息</h3><ol>
<li>waiting for monitor entry, 线程在等待进入临界区;一般此时线程状态都是Blocked</li>
<li>waiting on condition, 等待另一个条件来唤醒自己; 此时线程状态一般为WAITING(parking)或者TIMED_WAITING(parking或者sleeping).</li>
<li>in Object.wait(), 获取monitor之后, 又调用了wait()方法.此时线程状态一般为WAITING(on object monitor)或者TIMED_WAITING(on object monitor);</li>
</ol>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>使用时可以多dump几份，如果都指向同一个问题，才可以确定。查看线程所处的状态，如果某一批线程最新所在栈帧都是同一个方法的栈帧，或者都再等待同一个锁，则需要关注改方法的性能，以及过度使用锁同步的可能</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><pre><code>jmap -dump:live,format=b,file=someFile pid
将someFile 拷贝至本机（推荐）
jhat someFile 直至加在完毕
访问localhost:7000查看信息
</code></pre><h3 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h3><p>jmap具有停止服务, 强制执行gc等功能, 对线上服务慎用.</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><pre><code>netstat -anp | grep pid | sort -k5或
netstat -ap | grep pid |sort -k5
区别：-n打印的是ip，不加的-n打印机器名
sort -k5是按照所连接的其他机器ip排序，从而达到将相同ip聚合到一起便于观察的目的
</code></pre><h3 id="打印信息含义"><a href="#打印信息含义" class="headerlink" title="打印信息含义"></a>打印信息含义</h3><p>具体请参考 <a href="http://11376164.blog.51cto.com/11366164/1795032" target="_blank" rel="external">tcp连接的几种状态</a></p>
<ol>
<li>ESTABLISHED：(Connection established.)代表一个打开的连接</li>
<li>TIME-WAIT：(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认 — 常见于客户端</li>
<li>CLOSE-WAIT：等待从本地用户发来的连接中断请求，常见于服务端</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/04/26/spring/beanFactory_bean_analysis_register/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/26/spring/beanFactory_bean_analysis_register/" itemprop="url">
                  BeanFactory中Bean标签的解析及注册
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T00:00:00+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean。</p>
<p>BeanFactory：是IOC容器的核心接口， 它定义了IOC的基本功能，我们看到它主要定义了getBean方法。getBean方法是IOC容器获取bean对象和引发依赖注入的起点。方法的功能是返回特定的名称的Bean。</p>
<p>BeanFactory 是初始化 Bean 和调用它们生命周期方法的“吃苦耐劳者”。<strong>注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。</strong></p>
<p>BeanFactory有着庞大的继承、实现体系，有众多的子接口、实现类。来看一下BeanFactory的基本类体系结构（接口为主）：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493200448768.jpg" alt="enter description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.beans.factory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line"></div><div class="line">	String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; targetType)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">	</div><div class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</div><div class="line">	</div><div class="line">	String[] getAliases(String name);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体：</p>
<ol>
<li>4个获取实例的方法。getBean的重载方法。</li>
<li>4个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。</li>
<li>1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> spring.ioc.demo1;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String brand;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String color;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> brand;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.brand = brand;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> maxSpeed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"the car is:"</span>+ getBrand() + <span class="string">", color is:"</span> +getColor() +<span class="string">", maxspeed is:"</span>+getMaxSpeed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, String color, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.brand = brand;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"brand:"</span> + brand + <span class="string">";color:"</span> + color + <span class="string">";maxSpeed:"</span></div><div class="line">                + maxSpeed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car1"</span> <span class="attr">class</span>=<span class="string">"spring.ioc.demo1.Car"</span></span></div><div class="line">        <span class="attr">p:brand</span>=<span class="string">"spring注入-红旗001"</span> </div><div class="line">        <span class="attr">p:color</span>=<span class="string">"spring注入-紫色"</span> </div><div class="line">        <span class="attr">p:maxSpeed</span>=<span class="string">"520"</span> /&gt;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    　ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</div><div class="line">      Resource res = resolver.getResource(<span class="string">"classpath:applicationContext.xml"</span>);</div><div class="line">      BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(res);　　　　 </div><div class="line">　  <span class="comment">//ApplicationContext factory=new ClassPathXmlApplicationContext("applicationContext.xml");</span></div><div class="line">       Car car = factory.getBean(<span class="string">"car1"</span>,Car.class);</div><div class="line">       System.out.println(<span class="string">"car对象已经初始化完成"</span>);</div><div class="line">       System.out.println(car.getMaxSpeed());</div><div class="line">	   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>XmlBeanFactory通过Resource装载Spring配置信息冰启动IoC容器，然后就可以通过factory.getBean从IoC容器中获取Bean了。</li>
<li>通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。</li>
<li>对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。</li>
</ol>
<h2 id="XMLBeanFactory源码解析"><a href="#XMLBeanFactory源码解析" class="headerlink" title="XMLBeanFactory源码解析"></a>XMLBeanFactory源码解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">this</span>(resource, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">super</span>(parentBeanFactory);</div><div class="line">		<span class="keyword">this</span>.reader.loadBeanDefinitions(resource);<span class="comment">//核心方法</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入loadBeanDefinitions可以到达如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</div><div class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">			logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</div><div class="line">		&#125;</div><div class="line"><span class="comment">//resourcesCurrentlyBeingLoaded是一个ThreadLocal, 初次进入此代码currentResources为null</span></div><div class="line">		Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</div><div class="line">		<span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</div><div class="line">			currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</div><div class="line">			<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">					<span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			InputStream inputStream = encodedResource.getResource().getInputStream();</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//inputSource这个类来自org.xml.sax.InputResource</span></div><div class="line">				InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</div><div class="line">				<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</div><div class="line">					inputSource.setEncoding(encodedResource.getEncoding());</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//核心代码</span></div><div class="line">				<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">finally</span> &#123;</div><div class="line">				inputStream.close();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">					<span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">			currentResources.remove(encodedResource);</div><div class="line">			<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</div><div class="line">				<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>核心代码为doLoadBeanDefinitions(), 下面解析这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></div><div class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line">			<span class="comment">//其实这个方法当中就只有下面两行主要代码</span></div><div class="line">			<span class="comment">//这里面会: 1. 获取对XML文件的验证模式. 2. 加载XML文件, 得到对应的Document</span></div><div class="line">			Document doc = doLoadDocument(inputSource, resource);</div><div class="line">			<span class="comment">//核心代码, 3. 根据返回的Document注册bean信息</span></div><div class="line">			<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这个三个步骤支撑着整个Spring容器部分的实现基础，尤其是第三部对配置文件的解析，逻辑非常复杂，下面先从XML文件的验证模式说起。</p>
<h3 id="XML文件验证模式"><a href="#XML文件验证模式" class="headerlink" title="XML文件验证模式"></a>XML文件验证模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> validationModeToUse = getValidationMode();</div><div class="line">	<span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</div><div class="line">		<span class="keyword">return</span> validationModeToUse;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//没有指定是DTD还是XSD, 代码就会走到这里.</span></div><div class="line">	<span class="keyword">int</span> detectedMode = detectValidationMode(resource);</div><div class="line">	<span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</div><div class="line">		<span class="keyword">return</span> detectedMode;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 默认使用XSD方式</span></div><div class="line">	<span class="keyword">return</span> VALIDATION_XSD;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>detectValidationMode中的代码会 最终走到detectValidateionMode(InputStream inputStream)中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">detectValidationMode</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">boolean</span> isDtdValidated = <span class="keyword">false</span>;</div><div class="line">		String content;</div><div class="line">		<span class="comment">//一行一行的读取配置文件</span></div><div class="line">		<span class="keyword">while</span> ((content = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//去掉注释行</span></div><div class="line">			content = consumeCommentTokens(content);</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.inComment || !StringUtils.hasText(content)) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//判断是否为DTD模式</span></div><div class="line">			<span class="keyword">if</span> (hasDoctype(content)) &#123;</div><div class="line">				isDtdValidated = <span class="keyword">true</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//判断是否为XSD</span></div><div class="line">			<span class="keyword">if</span> (hasOpeningTag(content)) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (CharConversionException ex) &#123;</div><div class="line">		<span class="keyword">return</span> VALIDATION_AUTO;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">		reader.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h3><p>经过验证模式准备的步骤就可以进行Document加载了，同样XmlBeanFactoryReader类对于文档读取是委托给 DocumentLoader(接口)去执行。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</div><div class="line">			getValidationModeForResource(resource), isNamespaceAware());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DocumentLoader接口的实现类是DefaultDocumentLoader，解析代码如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></div><div class="line">		ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">	DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</div><div class="line">	&#125;</div><div class="line">	DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</div><div class="line">	<span class="keyword">return</span> builder.parse(inputSource);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过SAX解析XML文档的套路大致差不多，同样首先创建DocumentBuilderFactory，再通过DocumentBuilderFactory创建DocumentBuilder，进而解析inputSource来返回Document对象。</p>
<h3 id="解析并注册BeanDefinitions"><a href="#解析并注册BeanDefinitions" class="headerlink" title="解析并注册BeanDefinitions"></a>解析并注册BeanDefinitions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</div><div class="line">	documentReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</div><div class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</div><div class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</div><div class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的参数doc是通过上一节loadDocument()加载转换出来的，在这个方法中很好应用了面向对象中单一职责的原则，将逻辑处理委托给单一的类进行处理，这个逻辑处理类就是 BeanDefinitionDocumentReader 。它是一个接口，而实例化工作是在 createBeanDefinitionDocumentReader() 中完成的，而通过此方法，BeanDefinitionDocumentReader真正的类型时实际上就是 DefaultBeanDefinitionDocumentReader 了，进入 DefaultBeanDefinitionDocumentReader 后发现这个方法的重要目的之一就是提取root，以便于再次将root作为参数继续 BeanDefinition 的注册。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.readerContext = readerContext;</div><div class="line">	logger.debug(<span class="string">"Loading bean definitions"</span>);</div><div class="line">	Element root = doc.getDocumentElement();</div><div class="line">	doRegisterBeanDefinitions(root);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doRegisterBeanDefinitions(root)开始真正的解析工作, 之前都是准备阶段.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</div><div class="line">	String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</div><div class="line">	<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</div><div class="line">		Assert.state(<span class="keyword">this</span>.environment != <span class="keyword">null</span>, <span class="string">"Environment must be set for evaluating profiles"</span>);</div><div class="line">		String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</div><div class="line">				profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</div><div class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.environment.acceptsProfiles(specifiedProfiles)) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></div><div class="line">	<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></div><div class="line">	<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></div><div class="line">	<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></div><div class="line">	<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></div><div class="line">	<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></div><div class="line">	BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</div><div class="line">	<span class="keyword">this</span>.delegate = createDelegate(<span class="keyword">this</span>.readerContext, root, parent);</div><div class="line"></div><div class="line">	preProcessXml(root);</div><div class="line">	parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</div><div class="line">	postProcessXml(root);</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.delegate = parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面代码可以看到了处理流程，首先是对profile的处理，然后开始进行解析，preProcessXml(root)和postProcessXml(root)默认是空的。就像面向对象设计方法学中所说的一句话，一个类要么面向继承设计，要么就用final修饰。注意在 DefaultBeanDefinitionDocumentReader 中并没有用final修饰，所以它是面向继承设计的，而这两个方法正是为子类设计的: 模板方法模式！若继承自 DefaultBeanDefinitionDocumentReader 的子类需要在 Bean 解析前后做一些处理的话，只需要重写这两个方法即可。<br>Profile和Maven中的Profile类似,区分环境用的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</div><div class="line">		NodeList nl = root.getChildNodes();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</div><div class="line">			Node node = nl.item(i);</div><div class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</div><div class="line">				Element ele = (Element) node;</div><div class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</div><div class="line">					parseDefaultElement(ele, delegate);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					delegate.parseCustomElement(ele);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		delegate.parseCustomElement(root);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Spring的XML配置里面有两大类Bean声明，一个是默认的，如:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"com.hyj.test.TestBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>另一类是自定义的，如:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>这两种方式的读取和解析差别很大，若采用Spring默认配置，Spring当然知道如何做，但是如果是自定义的，就需要用户实现一些接口及配置来，对于根节点或子节点若是默认命名空间就采用 parseDefaultElement(…) 方法进行解析，否则使用 delegate.parseCustomElement(…) 方法对自定义命名空间进行解析，而判断是否默认命名空间还是自定义命名空间的办法实际上是使用node.getNamespaceURI获取命名空间，并与Spring中固定的命名空间 <a href="http://www.Springframework.org/schema/beans" target="_blank" rel="external">http://www.Springframework.org/schema/beans</a> 进行比对，若一致则认为是默认，否则就认为是自定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</div><div class="line">		importBeanDefinitionResource(ele);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</div><div class="line">		processAliasRegistration(ele);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</div><div class="line">		processBeanDefinition(ele, delegate);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</div><div class="line">		<span class="comment">// recurse</span></div><div class="line">		doRegisterBeanDefinitions(ele);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认标签的解析是在parseDefaultElement函数中进行的，分别对4种不同的标签（import,alias,bean和beans）做了不同处理。在4中标签中对bean标签的解析最为复杂也最为重要，所以从此标签开始深入分析，如果能理解这个标签的解析过程，其他标签的解析就迎刃而解了。首先看看函数processBeanDefinition(ele,delegate).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</div><div class="line"><span class="comment">//这里委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析工作.</span></div><div class="line"><span class="comment">//返回BeanDefinitionHolder的实例bdHolder, 经过这个方法后, bdHolder实例已经包含我们配置文件中的各种属性了</span></div><div class="line"><span class="comment">//比如class, name, id, alias之类等等.</span></div><div class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</div><div class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</div><div class="line">	    <span class="comment">//若存在默认标签的子节点下再有自定义属性, 还需要再次对自定义标签进行解析</span></div><div class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// Register the final decorated instance.</span></div><div class="line">			<span class="comment">//解析完成后, 对bdHolder进行注册.</span></div><div class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</div><div class="line">			getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</div><div class="line">					bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Send registration event.</span></div><div class="line">		<span class="comment">//发出通知, 通知相关监听器, 这个bean已经加载完成了.</span></div><div class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="解析配置文件属性"><a href="#解析配置文件属性" class="headerlink" title="解析配置文件属性"></a>解析配置文件属性</h4><p>首先分析parseBeanDefinitionElement(Element ele), 它是parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)的重载, containingBean参数传值为null;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</div><div class="line"><span class="comment">//解析ID属性</span></div><div class="line">	String id = ele.getAttribute(ID_ATTRIBUTE);</div><div class="line">	<span class="comment">//解析name属性</span></div><div class="line">	String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</div><div class="line"></div><div class="line">       <span class="comment">//name: 可以用特殊字符，并且一个bean可以用多个名称：name=“bean1,bean2,bean3” ,用逗号或者分号或者空格隔开。如果没有id，则name的第一个名称默认是id </span></div><div class="line">	List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</div><div class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</div><div class="line">		aliases.addAll(Arrays.asList(nameArr));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	String beanName = id;</div><div class="line">	<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</div><div class="line">		beanName = aliases.remove(<span class="number">0</span>);</div><div class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</div><div class="line">					<span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">       <span class="comment">//containingBean在这里必然为null;</span></div><div class="line">	<span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</div><div class="line">		checkNameUniqueness(beanName, aliases, ele);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">       <span class="comment">//对其它的属性进行解析</span></div><div class="line">	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</div><div class="line">	<span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">			    <span class="comment">//如果不存在beanName, name根据Spring中提供的命名规则为当前bean生成对应的beanName.</span></div><div class="line">				<span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</div><div class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</div><div class="line">							beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</div><div class="line">					<span class="comment">// Register an alias for the plain bean class name, if still possible,</span></div><div class="line">					<span class="comment">// if the generator returned the class name plus a suffix.</span></div><div class="line">					<span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></div><div class="line">					String beanClassName = beanDefinition.getBeanClassName();</div><div class="line">					<span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</div><div class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</div><div class="line">							!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</div><div class="line">						aliases.add(beanClassName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</div><div class="line">							<span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">				error(ex.getMessage(), ele);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</div><div class="line">		<span class="comment">//将获取到的信息封装到BeanDefinitionHolder的新的实例中</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其它属性的解析被封装到了parsebeanDefinitionElement中, 下面看其源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Parse the bean definition itself, without regard to name or aliases. May return</div><div class="line"> * &#123;<span class="doctag">@code</span> null&#125; if problems occurred during the parsing of the bean definition.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></div><div class="line">		Element ele, String beanName, BeanDefinition containingBean) &#123;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</div><div class="line"></div><div class="line">	String className = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//解析class属性</span></div><div class="line">	<span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</div><div class="line">		className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		String parent = <span class="keyword">null</span>;</div><div class="line">		<span class="comment">//解析parent属性</span></div><div class="line">		<span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</div><div class="line">			parent = ele.getAttribute(PARENT_ATTRIBUTE);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//创建用于承载属性的AbstractBeanDefinition类型的GenericBeanDefinition</span></div><div class="line">		AbstractBeanDefinition bd = createBeanDefinition(className, parent);</div><div class="line">		<span class="comment">//硬编码解析默认bean的各种属性</span></div><div class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</div><div class="line">		<span class="comment">//提取description</span></div><div class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</div><div class="line">		<span class="comment">//解析元数据</span></div><div class="line">		parseMetaElements(ele, bd);</div><div class="line">		<span class="comment">//解析lookup-method属性</span></div><div class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</div><div class="line">		<span class="comment">//解析replaced-method属性</span></div><div class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</div><div class="line">		<span class="comment">//解析构造函数参数</span></div><div class="line">		parseConstructorArgElements(ele, bd);</div><div class="line">		<span class="comment">//解析property子元素</span></div><div class="line">		parsePropertyElements(ele, bd);</div><div class="line">		<span class="comment">//解析qualifier子元素</span></div><div class="line">		parseQualifierElements(ele, bd);</div><div class="line"></div><div class="line">		bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</div><div class="line">		bd.setSource(extractSource(ele));</div><div class="line"></div><div class="line">		<span class="keyword">return</span> bd;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">		error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</div><div class="line">		error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">this</span>.parseState.pop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建用于承载属性的BeanDefinition, AbstractBeanDefinition bd = createBeanDefinition(className, parent)中的实际代码为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></div><div class="line">		String parentName, String className, ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line"></div><div class="line">	GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</div><div class="line">	<span class="comment">//parentName可能是没有配置过的, 所以可能为空</span></div><div class="line">	bd.setParentName(parentName);</div><div class="line">	<span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</div><div class="line">		    <span class="comment">//如果classLoader不为空, 则用传入的classLoader加载对象, 否则只是记录className</span></div><div class="line">			bd.setBeanClass(ClassUtils.forName(className, classLoader));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			bd.setBeanClassName(className);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> bd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数注入的解析具体是通过parseConstructorArgElement实现的, 源代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Parse a constructor-arg element.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</div><div class="line">	    <span class="comment">//获取index属性</span></div><div class="line">		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</div><div class="line">		<span class="comment">//获取Type属性</span></div><div class="line">		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</div><div class="line">		<span class="comment">//获取name属性</span></div><div class="line">		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</div><div class="line">		<span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</div><div class="line">		<span class="comment">//如果配置了index属性</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">int</span> index = Integer.parseInt(indexAttr);</div><div class="line">				<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">					error(<span class="string">"'index' cannot be lower than 0"</span>, ele);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</div><div class="line">						<span class="comment">//对属性值进行解析</span></div><div class="line">						Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</div><div class="line">						ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</div><div class="line">						<span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</div><div class="line">							valueHolder.setType(typeAttr);</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</div><div class="line">							valueHolder.setName(nameAttr);</div><div class="line">						&#125;</div><div class="line">						valueHolder.setSource(extractSource(ele));</div><div class="line">						<span class="comment">//不允许有重复index参数的值</span></div><div class="line">						<span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</div><div class="line">							error(<span class="string">"Ambiguous constructor-arg entries for index "</span> + index, ele);</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">else</span> &#123;</div><div class="line">						<span class="comment">//放入Map&lt;Integer, ValueHolder&gt; indexedArgumentValues</span></div><div class="line">							bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">finally</span> &#123;</div><div class="line">						<span class="keyword">this</span>.parseState.pop();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (NumberFormatException ex) &#123;</div><div class="line">				error(<span class="string">"Attribute 'index' of tag 'constructor-arg' must be an integer"</span>, ele);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//如果没有配置index属性</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</div><div class="line">				<span class="comment">//对属性值进行解析</span></div><div class="line">				Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</div><div class="line">				ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</div><div class="line">				<span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</div><div class="line">					valueHolder.setType(typeAttr);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</div><div class="line">					valueHolder.setName(nameAttr);</div><div class="line">				&#125;</div><div class="line">				valueHolder.setSource(extractSource(ele));</div><div class="line">				<span class="comment">//放入List&lt;ValueHolder&gt; genericArgumentValues中</span></div><div class="line">				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">finally</span> &#123;</div><div class="line">				<span class="keyword">this</span>.parseState.pop();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在parsePropertyValue中对构造器的属性值进行解析, 源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, String propertyName)</span> </span>&#123;</div><div class="line">		String elementName = (propertyName != <span class="keyword">null</span>) ?</div><div class="line">						<span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> :</div><div class="line">						<span class="string">"&lt;constructor-arg&gt; element"</span>;</div><div class="line"></div><div class="line">		<span class="comment">// Should only have one child element: ref, value, list, etc.</span></div><div class="line">		NodeList nl = ele.getChildNodes();</div><div class="line">		Element subElement = <span class="keyword">null</span>;</div><div class="line">		<span class="comment">//解析是否包含子元素</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</div><div class="line">			Node node = nl.item(i);</div><div class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</div><div class="line">					!nodeNameEquals(node, META_ELEMENT)) &#123;</div><div class="line">				<span class="comment">// Child element is what we're looking for.</span></div><div class="line">				<span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</div><div class="line">					error(elementName + <span class="string">" must not contain more than one sub-element"</span>, ele);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					subElement = (Element) node;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">        <span class="comment">//解析ref</span></div><div class="line">		<span class="keyword">boolean</span> hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);</div><div class="line">		<span class="comment">//解析value</span></div><div class="line">		<span class="keyword">boolean</span> hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);</div><div class="line">		<span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</div><div class="line">				((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="keyword">null</span>)) &#123;</div><div class="line">			error(elementName +</div><div class="line">					<span class="string">" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element"</span>, ele);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (hasRefAttribute) &#123;</div><div class="line">		    <span class="comment">//处理ref属性, 使用RuntimeBeanReference封装</span></div><div class="line">			String refName = ele.getAttribute(REF_ATTRIBUTE);</div><div class="line">			<span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</div><div class="line">				error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);</div><div class="line">			&#125;</div><div class="line">			RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</div><div class="line">			ref.setSource(extractSource(ele));</div><div class="line">			<span class="keyword">return</span> ref;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</div><div class="line">	        <span class="comment">//处理value属性, 使用TypedStringValue进行封装</span></div><div class="line">			TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</div><div class="line">			valueHolder.setSource(extractSource(ele));</div><div class="line">			<span class="keyword">return</span> valueHolder;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</div><div class="line">		    <span class="comment">//解析子元素</span></div><div class="line">			<span class="keyword">return</span> parsePropertySubElement(subElement, bd);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// Neither child element nor "ref" or "value" attribute found.</span></div><div class="line">			error(elementName + <span class="string">" must specify a ref or value"</span>, ele);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>代码最后涉及了子元素的处理, 例如下面的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">	     <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key"</span> <span class="attr">value</span>=<span class="string">'value'</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在parsePropertySubElement中实现了对各种子元素的分类处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Parse a value, ref or collection sub-element of a property or</div><div class="line"> * constructor-arg element.</div><div class="line"> * <span class="doctag">@param</span> ele subelement of property element; we don't know which yet</div><div class="line"> * <span class="doctag">@param</span> defaultValueType the default type (class name) for any</div><div class="line"> * &#123;<span class="doctag">@code</span> &amp;lt;value&amp;gt;&#125; tag that might be created</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, BeanDefinition bd, String defaultValueType)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;</div><div class="line">		<span class="keyword">return</span> parseNestedCustomElement(ele, bd);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</div><div class="line">		BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);</div><div class="line">		<span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;</div><div class="line">			nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> nestedBd;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;</div><div class="line">		<span class="comment">// A generic reference to any name of any bean.</span></div><div class="line">		String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);</div><div class="line">		<span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</div><div class="line">			<span class="comment">// A reference to the id of another bean in the same XML file.</span></div><div class="line">			refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);</div><div class="line">			<span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</div><div class="line">				<span class="comment">// A reference to the id of another bean in a parent context.</span></div><div class="line">				refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);</div><div class="line">				toParent = <span class="keyword">true</span>;</div><div class="line">				<span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;</div><div class="line">					error(<span class="string">"'bean', 'local' or 'parent' is required for &lt;ref&gt; element"</span>, ele);</div><div class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</div><div class="line">			error(<span class="string">"&lt;ref&gt; element contains empty target attribute"</span>, ele);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);</div><div class="line">		ref.setSource(extractSource(ele));</div><div class="line">		<span class="keyword">return</span> ref;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</div><div class="line">		<span class="keyword">return</span> parseIdRefElement(ele);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</div><div class="line">		<span class="keyword">return</span> parseValueElement(ele, defaultValueType);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</div><div class="line">		<span class="comment">// It's a distinguished null value. Let's wrap it in a TypedStringValue</span></div><div class="line">		<span class="comment">// object in order to preserve the source location.</span></div><div class="line">		TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);</div><div class="line">		nullHolder.setSource(extractSource(ele));</div><div class="line">		<span class="keyword">return</span> nullHolder;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</div><div class="line">		<span class="keyword">return</span> parseArrayElement(ele, bd);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</div><div class="line">		<span class="keyword">return</span> parseListElement(ele, bd);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;</div><div class="line">		<span class="keyword">return</span> parseSetElement(ele, bd);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</div><div class="line">		<span class="keyword">return</span> parseMapElement(ele, bd);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</div><div class="line">		<span class="keyword">return</span> parsePropsElement(ele);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		error(<span class="string">"Unknown property sub-element: ["</span> + ele.getNodeName() + <span class="string">"]"</span>, ele);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>spring支持的子元素已经全部在上面处理了.</p>
<h4 id="AbstractBeanDefinition属性"><a href="#AbstractBeanDefinition属性" class="headerlink" title="AbstractBeanDefinition属性"></a>AbstractBeanDefinition属性</h4><p>经过上面一节复杂代码的处理, 完成了XML文档到GenericBeanDefinition的转化, 也就是说所有的XML配置都已经实例化为了GenericBeanDefinition的实例中的属性.<br>其大部分属性(除了partnerName)均保存在AbstractBeanDefinition中, 重要的属性如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bean的作用范围, 对应bean的属性scope</span></div><div class="line">	<span class="keyword">private</span> String scope = SCOPE_DEFAULT;</div><div class="line"><span class="comment">//是否抽象, 对应bean的属性abstract</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> abstractFlag = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//是否延迟加载, 对应bean的属性lazy-init</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//自动注入模式, 对应bean属性autowire</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> autowireMode = AUTOWIRE_NO;</div><div class="line"><span class="comment">//依赖检查, spring3.0之后弃用这个属性</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> dependencyCheck = DEPENDENCY_CHECK_NONE;</div><div class="line"><span class="comment">//用来表示一个bean的实例化依靠另一个bean的实例化, 对应bean属性depend-on</span></div><div class="line">	<span class="keyword">private</span> String[] dependsOn;</div><div class="line">	<span class="comment">//该属性设置为false时, 容器在查找自动装配对象时, 将不考虑该bean</span></div><div class="line">	<span class="comment">//也就是说这个bean不会被考虑作为其它bean自动装配的候选者, 但是该bean本身还是可以使用自动装配来注入其它bean的.</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> autowireCandidate = <span class="keyword">true</span>;</div><div class="line">	<span class="comment">//自动装配出现多个候选者时作为首选者, 对应bean属性primary.</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> primary = <span class="keyword">false</span>;</div><div class="line">	<span class="comment">//用来记录Qualifier, 对应子元素Qualifier</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = <span class="keyword">new</span> LinkedHashMap&lt;String, AutowireCandidateQualifier&gt;(<span class="number">0</span>);</div><div class="line">	<span class="comment">//允许访问非公开的构造器和方法, 程序设置</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> nonPublicAccessAllowed = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//是否以一种宽松的模式解析构造函数, 默认为true;</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> lenientConstructorResolution = <span class="keyword">true</span>;</div><div class="line"><span class="comment">//记录构造函数注入属性, 对应bean属性constructor-arg</span></div><div class="line">	<span class="keyword">private</span> ConstructorArgumentValues constructorArgumentValues;</div><div class="line"><span class="comment">//普通属性集合</span></div><div class="line">	<span class="keyword">private</span> MutablePropertyValues propertyValues;</div><div class="line"><span class="comment">//方法重写持有者, 记录lookup-method, replaced-method元素</span></div><div class="line">	<span class="keyword">private</span> MethodOverrides methodOverrides = <span class="keyword">new</span> MethodOverrides();</div><div class="line"><span class="comment">//对应bean属性factoryBean</span></div><div class="line">	<span class="keyword">private</span> String factoryBeanName;</div><div class="line"><span class="comment">//对应bean属性factory-method</span></div><div class="line">	<span class="keyword">private</span> String factoryMethodName;</div><div class="line"><span class="comment">//对应bean属性init-method</span></div><div class="line">	<span class="keyword">private</span> String initMethodName;</div><div class="line"><span class="comment">//对应bean属性destroy-method</span></div><div class="line">	<span class="keyword">private</span> String destroyMethodName;</div><div class="line"><span class="comment">//是否执行init-method, 程序设置</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> enforceInitMethod = <span class="keyword">true</span>;</div><div class="line"><span class="comment">//是否执行destroy-method, 程序设置</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> enforceDestroyMethod = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> synthetic = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> role = BeanDefinition.ROLE_APPLICATION;</div><div class="line"><span class="comment">//描述信息</span></div><div class="line">	<span class="keyword">private</span> String description;</div><div class="line"><span class="comment">//这个bean定义的</span></div><div class="line">	<span class="keyword">private</span> Resource resource;</div></pre></td></tr></table></figure></p>
<h4 id="注册解析的beanDefinition"><a href="#注册解析的beanDefinition" class="headerlink" title="注册解析的beanDefinition"></a>注册解析的beanDefinition</h4><p>对配置文件解析完成之后,获取的beanDefinition已经可以使用了, 剩下的工作就是开始注册, 也就是processBeanDefinition方法中的BeanDefinitionReaderUtils.registerBeanDefinition();<br>其源代码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Register the given bean definition with the given bean factory.</div><div class="line"> * <span class="doctag">@param</span> definitionHolder the bean definition including name and aliases</div><div class="line"> * <span class="doctag">@param</span> registry the bean factory to register with</div><div class="line"> * <span class="doctag">@throws</span> BeanDefinitionStoreException if registration failed</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></div><div class="line">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</div><div class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line"></div><div class="line">	<span class="comment">// Register bean definition under primary name.</span></div><div class="line">	String beanName = definitionHolder.getBeanName();</div><div class="line">	<span class="comment">//根据beanName注册</span></div><div class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</div><div class="line"></div><div class="line">	<span class="comment">// Register aliases for bean name, if any.</span></div><div class="line">	String[] aliases = definitionHolder.getAliases();</div><div class="line">	<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="comment">//根据别名注册</span></div><div class="line">		<span class="keyword">for</span> (String aliase : aliases) &#123;</div><div class="line">			registry.registerAlias(beanName, aliase);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于根据beanName注册源代码如下, 具体是讲beanDefinition直接放入map中, 以beanName为key, 但是不仅仅如此:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></div><div class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line"></div><div class="line">		Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</div><div class="line">		Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				((AbstractBeanDefinition) beanDefinition).validate();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</div><div class="line">						<span class="string">"Validation of bean definition failed"</span>, ex);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		BeanDefinition oldBeanDefinition;</div><div class="line"></div><div class="line"><span class="comment">//虽然beanDefinitionMap是concurrentHashMap, 但是下面代码中并非原子操作, 所以需要同步, 因为可能会并发访问.</span></div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</div><div class="line">			oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</div><div class="line">			<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">//如果已经注册了这个beanname</span></div><div class="line">				<span class="keyword">if</span> (!<span class="keyword">this</span>.allowBeanDefinitionOverriding) &#123;</div><div class="line">				<span class="comment">//不允许覆盖,抛出异常</span></div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</div><div class="line">							<span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</div><div class="line">							<span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</div><div class="line">					<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></div><div class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</div><div class="line">						<span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</div><div class="line">								<span class="string">" with a framework-generated bean definition ': replacing ["</span> +</div><div class="line">								oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</div><div class="line">						<span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</div><div class="line">								<span class="string">"': replacing ["</span> + oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//记录下要被注册的beanName</span></div><div class="line">				<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</div><div class="line">				<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//注册beanDefinition</span></div><div class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</div><div class="line">		    <span class="comment">//重置所有的beanname对应的缓存</span></div><div class="line">			resetBeanDefinition(beanName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>以下是通过别名注册BeanDefinition的源代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>&#123;</div><div class="line">	Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</div><div class="line">	Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</div><div class="line">	<span class="comment">//beanName和alias相同的话, 则不注册</span></div><div class="line">	<span class="keyword">if</span> (alias.equals(name)) &#123;</div><div class="line">		<span class="keyword">this</span>.aliasMap.remove(alias);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">//如果alias不允许被覆盖, 则抛出异常, 这个参数其实就是allowBeanDefinitionOverriding</span></div><div class="line">		<span class="keyword">if</span> (!allowAliasOverriding()) &#123;</div><div class="line">			String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</div><div class="line">			<span class="keyword">if</span> (registeredName != <span class="keyword">null</span> &amp;&amp; !registeredName.equals(name)) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot register alias '"</span> + alias + <span class="string">"' for name '"</span> +</div><div class="line">						name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//如果aliasMap中name已经对应了alias, 那就抛出异常</span></div><div class="line">		checkForAliasCircle(name, alias);</div><div class="line">		<span class="comment">//注册alias</span></div><div class="line">		<span class="keyword">this</span>.aliasMap.put(alias, name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/04/24/lock/reentrantlock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/lock/reentrantlock/" itemprop="url">
                  可重入锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T00:00:00+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/锁/" itemprop="url" rel="index">
                    <span itemprop="name">锁</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文中所说的可重入锁是广义上的, 不单指Java中的ReentrantLock.<br>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。<br>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">		set();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(Thread.currentThread().getId());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		get();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Test ss=<span class="keyword">new</span> Test();</div><div class="line">		<span class="keyword">new</span> Thread(ss).start();</div><div class="line">		<span class="keyword">new</span> Thread(ss).start();</div><div class="line">		<span class="keyword">new</span> Thread(ss).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReentrantLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        System.out.println(Thread.currentThread().getId());</div><div class="line">        set();</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        System.out.println(Thread.currentThread().getId());</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TestReentrantLock ss = <span class="keyword">new</span> TestReentrantLock();</div><div class="line">        <span class="keyword">new</span> Thread(ss).start();</div><div class="line">        <span class="keyword">new</span> Thread(ss).start();</div><div class="line">        <span class="keyword">new</span> Thread(ss).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个例子最后的结果都是正确的，即 同一个线程id被连续输出两次。结果如下：</p>
<p>Threadid: 8<br>Threadid: 8<br>Threadid: 10<br>Threadid: 10<br>Threadid: 9<br>Threadid: 9</p>
<p>可重入锁最大的作用是避免死锁.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner =<span class="keyword">new</span> AtomicReference&lt;&gt;();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		<span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, current))&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		owner.compareAndSet(current, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于自旋锁来说，<br>1、若有同一线程两调用lock() ，会导致第二次调用lock位置进行自旋，产生了死锁<br>说明这个锁并不是可重入的。（在lock函数内，应验证线程是否为已经获得锁的线程）<br>2、若1问题已经解决，当unlock（）第一次调用时，就已经将锁释放了。实际上不应释放锁。<br>（采用计数次进行统计）<br>修改之后，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock1</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner =<span class="keyword">new</span> AtomicReference&lt;&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		<span class="keyword">if</span>(current==owner.get()) &#123;</div><div class="line">			count++;</div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">while</span>(!owner.compareAndSet(<span class="keyword">null</span>, current))&#123;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</div><div class="line">		Thread current = Thread.currentThread();</div><div class="line">		<span class="keyword">if</span>(current==owner.get())&#123;</div><div class="line">			<span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</div><div class="line">				count--;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				owner.compareAndSet(current, <span class="keyword">null</span>);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该自旋锁即为可重入锁。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/04/24/memmodel/memmodel_base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/memmodel/memmodel_base/" itemprop="url">
                  深入理解Java内存模型(一)-基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T00:00:00+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/内存模型/" itemprop="url" rel="index">
                    <span itemprop="name">内存模型</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h2><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。<br>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。<br>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h2 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h2><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493024854057.jpg" alt="enter description here"></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。<br>下面通过示意图来说明这两个步骤：</li>
</ol>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493025109511.jpg" alt="enter description here"></p>
<p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</li>
</ol>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493025500915.jpg" alt="enter description here"><br>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h2><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493028472190.jpg" alt="enter description here"><br>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493028552998.jpg" alt="enter description here"><br>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。<br>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。<br>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。<br>下面是常见处理器允许的重排序类型的列表：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493028714569.jpg" alt="enter description here"><br>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。<br>从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。<br>※注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。<br>※注2：上表中的x86包括x64及AMD64。<br>※注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。<br>※注4：数据依赖性后文会专门说明。<br>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493028835831.jpg" alt="enter description here"></p>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li>
</ol>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。<br>happens-before与JMM的关系如下图所示：<br><img src="https://www.github.com/sd1026203/img/raw/master/1493030836681.jpg" alt="enter description here"><br>如上图所示，一个happens-before规则通常对应于多个编译器和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/04/24/memmodel/memmodel_final/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/memmodel/memmodel_final/" itemprop="url">
                  深入理解Java内存模型(六)-final
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T00:00:00+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/内存模型/" itemprop="url" rel="index">
                    <span itemprop="name">内存模型</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p> 对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ol>
<p>下面，我们通过一些示例性的代码来分别说明这两个规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;                            <span class="comment">//普通变量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                      <span class="comment">//final变量</span></div><div class="line">    <span class="keyword">static</span> FinalExample obj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span> <span class="params">()</span> </span>&#123;     <span class="comment">//构造函数</span></div><div class="line">        i = <span class="number">1</span>;                        <span class="comment">//写普通域</span></div><div class="line">        j = <span class="number">2</span>;                        <span class="comment">//写final域</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span> <span class="params">()</span> </span>&#123;    <span class="comment">//写线程A执行</span></div><div class="line">        obj = <span class="keyword">new</span> FinalExample ();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;       <span class="comment">//读线程B执行</span></div><div class="line">        FinalExample object = obj;       <span class="comment">//读对象引用</span></div><div class="line">        <span class="keyword">int</span> a = object.i;                <span class="comment">//读普通域</span></div><div class="line">        <span class="keyword">int</span> b = object.j;                <span class="comment">//读final域</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h2 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h2><p> 写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p>
<ol>
<li>JMM(Java Memory Model, Java内存模型)禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ol>
<p>现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p>
<ol>
<li>构造一个FinalExample类型的对象；</li>
<li>把这个对象的引用赋值给引用变量obj。</li>
</ol>
<p>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493014011136.jpg" alt="执行时序"><br> 在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。</p>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。</p>
<h2 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h2><p> 读final域的重排序规则如下：</p>
<ol>
<li><p>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</p>
<p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。<br>reader()方法包含三个操作：</p>
</li>
</ol>
<ol>
<li>初次读引用变量obj;</li>
<li>初次读引用变量obj指向对象的普通域i。</li>
<li>初次读引用变量obj指向对象的final域j。</li>
</ol>
<p>现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493014869480.jpg" alt="enter description here"></p>
<p> 在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。</p>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h2 id="如果final域是引用类型"><a href="#如果final域是引用类型" class="headerlink" title="如果final域是引用类型"></a>如果final域是引用类型</h2><p>请看示例代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] intArray;                     <span class="comment">//final是引用类型</span></div><div class="line"><span class="keyword">static</span> FinalReferenceExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExample</span> <span class="params">()</span> </span>&#123;        <span class="comment">//构造函数</span></div><div class="line">    intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];              <span class="comment">//1</span></div><div class="line">    intArray[<span class="number">0</span>] = <span class="number">1</span>;                   <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerOne</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程A执行</span></div><div class="line">    obj = <span class="keyword">new</span> FinalReferenceExample ();  <span class="comment">//3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTwo</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程B执行</span></div><div class="line">    obj.intArray[<span class="number">0</span>] = <span class="number">2</span>;                 <span class="comment">//4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;              <span class="comment">//读线程C执行</span></div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                    <span class="comment">//5</span></div><div class="line">        <span class="keyword">int</span> temp1 = obj.intArray[<span class="number">0</span>];       <span class="comment">//6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 这里final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：</p>
<ol>
<li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ol>
<p>对上面的示例程序，我们假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader ()方法。下面是一种可能的线程执行时序：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493015580964.jpg" alt="enter description here"></p>
<p> 在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h2 id="为什么final引用不能从构造函数内”逸出”"><a href="#为什么final引用不能从构造函数内”逸出”" class="headerlink" title="为什么final引用不能从构造函数内”逸出”"></a>为什么final引用不能从构造函数内”逸出”</h2><p>前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> i;</div><div class="line"><span class="keyword">static</span> FinalReferenceEscapeExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</div><div class="line">    i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></div><div class="line">    obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;</div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></div><div class="line">        <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：</p>
<p><img src="https://www.github.com/sd1026203/img/raw/master/1493017671927.jpg" alt="enter description here"><br>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h2 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a>final语义在处理器中的实现</h2><p> 现在我们以x86处理器为例，说明final语义在处理器中的具体实现。</p>
<p>上面我们提到，写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p>
<p>由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障！</p>
<h2 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h2><p> 在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref=pd_sim_b_1" target="_blank" rel="external">Java Concurrency in Practice</a></li>
<li><a href="https://www.cs.umd.edu/users/pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="external">JSR 133 (Java Memory Model) FAQ</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="external">The JSR-133 Cookbook for Compiler Writers</a></li>
<li><a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html" target="_blank" rel="external">Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/04/23/lock/spinlock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/23/lock/spinlock/" itemprop="url">
                  自旋锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-23T00:00:00+08:00">
                2017-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/锁/" itemprop="url" rel="index">
                    <span itemprop="name">锁</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁是采用让当前线程不停的在循环体内执行实现的， 当循环的条件被其它线程改变时才能进入临界区。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123; 	 </div><div class="line"> <span class="keyword">private</span> AtomicReference&lt;Thread&gt; sign =newAtomicReference&lt;&gt;(); 	 </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</div><div class="line">      Thread current = Thread.currentThread();</div><div class="line">      <span class="keyword">while</span>(!sign .compareAndSet(<span class="keyword">null</span>, current))&#123;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span></span>&#123;</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    sign .compareAndSet(current, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：该例子为非公平锁，获得锁的先后顺序，不会按照进入lock的先后顺序进行。<br>lock函数使用了CAS原子操作， 将owner设置为当前线程， 并且预测原来的值为空。unlock函数将owner设置为null，并且预测值为当前线程。<br>当有第二个线程调用lock操作时由于owner值不为空，导致循环一直被执行，直至第一个线程调用unlock函数将owner设置为null，第二个线程才能进入临界区。<br>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。<br>如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。</p>
<h1 id="自旋锁的其它种类"><a href="#自旋锁的其它种类" class="headerlink" title="自旋锁的其它种类"></a>自旋锁的其它种类</h1><p>锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利，但是锁的具体性质以及类型却很少被提及。本系列文章将分析JAVA下常见的锁名称以及特性，为大家答疑解惑。在自旋锁中 另有三种常见的锁形式:TicketLock ，CLHlock 和MCSlock。</p>
<h2 id="TicketLock"><a href="#TicketLock" class="headerlink" title="TicketLock"></a>TicketLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.alipay.titan.dcc.dal.entity; 	 </div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger; 	 </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> AtomicInteger ticketNum  = <span class="keyword">new</span> AtomicInteger();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; LOCAL      = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> myticket = ticketNum.getAndIncrement();</div><div class="line">        LOCAL.set(myticket);</div><div class="line">        <span class="keyword">while</span> (myticket != serviceNum.get()) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> myticket = LOCAL.get();</div><div class="line">        serviceNum.compareAndSet(myticket, myticket + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次都要查询一个serviceNum 服务号，影响性能（必须要到主内存读取，并阻止其他cpu修改）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="sd1026203.github.io/2017/04/22/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="葛伟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="高山仰止,景行行止">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/22/hello-world/" itemprop="url">
                  高山仰止 景行行止
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-22T00:00:00+08:00">
                2017-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前的很长时间， 没有自己的博客， 没有自己的积累， 今天起， 像个大牛一样要求自己吧！!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="葛伟" />
          <p class="site-author-name" itemprop="name">葛伟</p>
           
              <p class="site-description motion-element" itemprop="description">记录我的学习历程</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">葛伟</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
